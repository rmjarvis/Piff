<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>piff.basis_interp &mdash; Piff 1.6.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=72d88caf"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Piff
          </a>
              <div class="version">
                1.6
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">PIFF: PSFs In the Full FOV</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../piffify.html">The piffify executable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input.html">Reading in Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../select.html">Selecting Good PSF Stars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../model.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../interp.html">Interpolation Schemes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../psf.html">PSF classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../outliers.html">Removing Outliers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../output.html">Writing the output file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stats.html">Output statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../star.html">Stars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../util.html">Utility Functions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Piff</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">piff.basis_interp</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for piff.basis_interp</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2016 by Mike Jarvis and the other collaborators on GitHub at</span>
<span class="c1"># https://github.com/rmjarvis/Piff  All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Piff is free software: Redistribution and use in source and binary forms</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: interp</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">import</span> <span class="nn">galsim</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.interp</span> <span class="kn">import</span> <span class="n">Interp</span>
<span class="kn">from</span> <span class="nn">.star</span> <span class="kn">import</span> <span class="n">Star</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_piff</span>
<span class="kn">from</span> <span class="nn">.config</span> <span class="kn">import</span> <span class="n">LoggerWrapper</span>

<span class="k">try</span><span class="p">:</span> 
    <span class="kn">import</span> <span class="nn">jax</span>
    <span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">jit</span>
    <span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span>
    <span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">vmap</span>

<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">CAN_USE_JAX</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># define dummy functions for jax</span>
    <span class="k">def</span> <span class="nf">jit</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">CAN_USE_JAX</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;jax_enable_x64&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># Bellow are implementations of _solve_direct using JAX.</span>
<span class="c1"># if jax.config.update(&quot;jax_enable_x64&quot;, True) it will give the</span>
<span class="c1"># same results as the original code in double precision, but will run</span>
<span class="c1"># slower, but still faster than the numpy/scipy version.</span>

<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">jax_solve</span><span class="p">(</span><span class="n">ATA</span><span class="p">,</span> <span class="n">ATb</span><span class="p">):</span>
    <span class="c1"># Original code:</span>
    <span class="c1"># dq = scipy.linalg.solve(ATA, ATb, assume_a=&#39;pos&#39;, check_finite=False)</span>
    <span class="c1"># New code:</span>
    <span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">ATA</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">dq</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">((</span><span class="n">factor</span><span class="p">,</span> <span class="n">lower</span><span class="p">),</span> <span class="n">ATb</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dq</span>

<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">build_ATA_ATb</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="n">ATb</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="p">[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">tmp1</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">K</span>
    <span class="n">ATA</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp1</span><span class="p">[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">ATA</span><span class="p">,</span> <span class="n">ATb</span>

<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">vmap_build_ATA_ATb</span><span class="p">(</span><span class="n">Ks</span><span class="p">,</span> <span class="n">alphas</span><span class="p">,</span> <span class="n">betas</span><span class="p">):</span>
    <span class="c1"># Use vmap to vectorize build_ATA_ATb across the first dimension of Ks, alphas, and betas</span>
    <span class="n">vmapped_build_ATA_ATb</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">build_ATA_ATb</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># Get the vectorized results</span>
    <span class="n">ATAs</span><span class="p">,</span> <span class="n">ATbs</span> <span class="o">=</span> <span class="n">vmapped_build_ATA_ATb</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="n">betas</span><span class="p">,</span> <span class="n">Ks</span><span class="p">)</span>
    <span class="c1"># Sum the results along the first axis</span>
    <span class="n">ATb</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ATbs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ATA</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ATAs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ATA</span><span class="p">,</span> <span class="n">ATb</span>


<div class="viewcode-block" id="BasisInterp">
<a class="viewcode-back" href="../../interp.html#piff.BasisInterp">[docs]</a>
<span class="k">class</span> <span class="nc">BasisInterp</span><span class="p">(</span><span class="n">Interp</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;An Interp class that works whenever the interpolating functions are</span>
<span class="sd">    linear sums of basis functions.  Does things the &quot;slow way&quot; to be stable to</span>
<span class="sd">    degenerate fits to individual stars, instead of fitting to parameter sets</span>
<span class="sd">    produced by single stars.</span>

<span class="sd">    First time coding this we will assume that each element of the PSF parameter</span>
<span class="sd">    vector p is a linear combination of the same set of basis functions across the</span>
<span class="sd">    focal plane,</span>

<span class="sd">    .. math::</span>

<span class="sd">        p_i = \sum_{j} q_{ij} K_j(u,v,other stellar params).</span>

<span class="sd">    The property degenerate_points is set to True to indicate that this interpolator</span>
<span class="sd">    uses the alpha/beta quadratic form of chisq for each sample, rather than assuming</span>
<span class="sd">    that a best-fit parameter vector is available at every sample.</span>

<span class="sd">    Internally we&#39;ll store the interpolation coefficients in a 2d array of dimensions</span>
<span class="sd">    (nparams, nbases)</span>

<span class="sd">    Note: This is an abstract base class.  The concrete class you probably want to use</span>
<span class="sd">    is BasisPolynomial.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_type_name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degenerate_points</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># This Interpolator uses chisq quadratic forms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;scipy&quot;</span>  <span class="c1"># The default.  May be overridden by subclasses.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_num</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="BasisInterp.initialize">
<a class="viewcode-back" href="../../interp.html#piff.BasisInterp.initialize">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stars</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize both the interpolator to some state prefatory to any solve iterations and</span>
<span class="sd">        initialize the stars for use with this interpolator.</span>

<span class="sd">        This class will initialize everything to have constant PSF parameter vector taken</span>
<span class="sd">        from the first Star in the list.</span>

<span class="sd">        :param stars:       A list of Star instances to use to initialize.</span>
<span class="sd">        :param logger:      A logger object for logging debug info. [default: None]</span>

<span class="sd">        :returns:           A new list of Stars which have their parameters initialized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">get_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stars</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">is_flagged</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;All stars are flagged.  Cannot initialize BasisPolynomial.&quot;</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">1.</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
        <span class="n">stars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolateList</span><span class="p">(</span><span class="n">stars</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stars</span></div>


<div class="viewcode-block" id="BasisInterp.basis">
<a class="viewcode-back" href="../../interp.html#piff.BasisInterp.basis">[docs]</a>
    <span class="k">def</span> <span class="nf">basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return 1d array of polynomial basis values for this star</span>

<span class="sd">        :param star:   A Star instance</span>

<span class="sd">        :returns:      1d numpy array with values of u^i v^j for 0&lt;i+j&lt;=order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot call `basis` for abstract base class BasisInterp. &quot;</span>
                                  <span class="s2">&quot;You probably want to use BasisPolynomial.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterp.constant">
<a class="viewcode-back" href="../../interp.html#piff.BasisInterp.constant">[docs]</a>
    <span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return 1d array of coefficients that represent a polynomial with constant value.</span>

<span class="sd">        :param value:  The value to use as the constant term.  [default: 1.]</span>

<span class="sd">        :returns:      1d numpy array with values of u^i v^j for 0&lt;i+j&lt;=order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot call `constant` for abstract base class BasisInterp. &quot;</span>
                                  <span class="s2">&quot;You probably want to use BasisPolynomial.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterp.solve">
<a class="viewcode-back" href="../../interp.html#piff.BasisInterp.solve">[docs]</a>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stars</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve for the interpolation coefficients given some data.</span>
<span class="sd">        The StarFit element of each Star in the list is assumed to hold valid</span>
<span class="sd">        alpha and beta members specifying depending of chisq on differential</span>
<span class="sd">        changes to its parameter vector.</span>

<span class="sd">        :param stars:       A list of Star instances to interpolate between</span>
<span class="sd">        :param logger:      A logger object for logging debug info. [default: None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerWrapper</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Attempt to solve() before initialize() of BasisInterp&quot;</span><span class="p">)</span>

        <span class="c1"># The inputs to this function are for each star i the design equation is</span>
        <span class="c1">#</span>
        <span class="c1">#   A_i p = b_i</span>
        <span class="c1">#</span>
        <span class="c1"># The parameters at each stars location are modeled as</span>
        <span class="c1">#</span>
        <span class="c1">#   p_i = q . K_i(u_i,v_i,...)</span>
        <span class="c1">#</span>
        <span class="c1"># where K is the basis vector for the particular location of this star and q is</span>
        <span class="c1"># our 2d array of fitting parameters.  There is a row in q for each element of p,</span>
        <span class="c1"># and a column in q for each element in K.</span>
        <span class="c1">#</span>
        <span class="c1"># Each star then gives us nparam equations, which become rows of our full design matrix.</span>
        <span class="c1"># Consider the first equation for one star:</span>
        <span class="c1">#</span>
        <span class="c1">#   A[0,:] p = b[0]</span>
        <span class="c1">#   A[0,:] q K = b[0]</span>
        <span class="c1">#</span>
        <span class="c1"># Each element in the A[0,:]T KT outer product is the coefficient of a single element q_mn.</span>
        <span class="c1"># So we can rewrite this as</span>
        <span class="c1">#</span>
        <span class="c1">#   (A[0,:,np.newaxis] * K[np.newaxis,:]).flatten() * q.flatten() = b[0]</span>
        <span class="c1">#</span>
        <span class="c1"># Thus, the equation we want for our big design matrix has rows with</span>
        <span class="c1">#</span>
        <span class="c1">#   (A_i[j,:,np.newaxis] * K_i[np.newaxis,:]).flatten()</span>
        <span class="c1">#</span>
        <span class="c1"># and the b vector has elements</span>
        <span class="c1">#</span>
        <span class="c1">#   b_i[j]</span>
        <span class="c1">#</span>
        <span class="c1"># Now, the typical usage of this class is such that the size of A is</span>
        <span class="c1">#</span>
        <span class="c1">#   (nstars * npixels x nparam * nbasis)</span>
        <span class="c1">#</span>
        <span class="c1"># Typical numbers are:</span>
        <span class="c1">#</span>
        <span class="c1">#   nstars ~ 100</span>
        <span class="c1">#   npixels ~ 500</span>
        <span class="c1">#   nparam ~ 400</span>
        <span class="c1">#   nbasis ~ 6</span>
        <span class="c1">#</span>
        <span class="c1"># So the size of A is ~ 50,000 x 2,400, which for double precision is about 1 GB.</span>
        <span class="c1"># Considering that a particular CCD in a dense field might have up to 10 times this many</span>
        <span class="c1"># stars, this is a very steep memory demand for this function.</span>
        <span class="c1">#</span>
        <span class="c1"># Therefore, we make the default behavior be to construct AT A and solve AT A dq = AT b.</span>
        <span class="c1"># But we have an option to use QR decomposition of A instead, which may have stability</span>
        <span class="c1"># advantages, since the condition of AT A is the square of the condition of A, so the</span>
        <span class="c1"># QR method often has fewer numerical problems than the direct method for large matrices.</span>
        <span class="c1"># It just requires a lot of memory.</span>

        <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerWrapper</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;qr&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solve_qr</span><span class="p">(</span><span class="n">stars</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solve_direct</span><span class="p">(</span><span class="n">stars</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span></div>



<div class="viewcode-block" id="BasisInterp._solve_qr">
<a class="viewcode-back" href="../../interp.html#piff.BasisInterp._solve_qr">[docs]</a>
    <span class="k">def</span> <span class="nf">_solve_qr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stars</span><span class="p">,</span> <span class="n">logger</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The implementation of solve() when use_qr = True.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># First, build up one chunk for each star.  We&#39;ll stack them later.</span>
        <span class="n">A_chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">b_chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stars</span><span class="p">:</span>
            <span class="c1"># Get the basis function values at this star</span>
            <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">b_chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
            <span class="n">A_chunks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">A</span><span class="p">[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">K</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="p">)))</span>

        <span class="c1"># Now stack the chunks into a single A and b.</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">A_chunks</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">b_chunks</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stars</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="ow">or</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Too few constraints for solution. (Probably too few stars)&quot;</span><span class="p">)</span>

        <span class="c1"># Note: The following snippet is the straightforward way to do this using the</span>
        <span class="c1">#       scipy qr function.  However, it generates the full Q matrix, which is slow.</span>
        <span class="c1">#       Using the lapack functions directly is slightly more obfuscated, but faster.</span>
        <span class="c1">#Q,R = scipy.linalg.qr(A, mode=&#39;economic&#39;, overwrite_a=True)</span>
        <span class="c1">#dq = Q.T.dot(b)</span>
        <span class="c1">#dq = scipy.linalg.solve_triangular(R, dq, overwrite_b=True, check_finite=False)</span>

        <span class="c1"># This computes A -&gt; Q R, where QR are stored in a single matrix along with an</span>
        <span class="c1"># ancillary tau matrix that helps define the Householder matrices used to build</span>
        <span class="c1"># the real Q.</span>
        <span class="n">QR</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lapack</span><span class="o">.</span><span class="n">dgeqrf</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Check the diagonal values of the R matrix.  The following calculation isn&#39;t a</span>
        <span class="c1"># real condition number, since the regular QR decomposition isn&#39;t actually rank</span>
        <span class="c1"># revealing.  However, we only get problems with the normal QR decomposition if</span>
        <span class="c1"># this number is very small, in which case we should switch to a QRP decomposition.</span>
        <span class="n">abs_Rdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">QR</span><span class="p">))</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">abs_Rdiag</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">abs_Rdiag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cond</span> <span class="o">&lt;</span> <span class="mf">1.e-12</span><span class="p">:</span>
            <span class="c1"># Note: this calculation is much slower, but it is safe to use even for</span>
            <span class="c1"># singular inputs, so it will always produce a valid answer.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="s1">&#39;Nominal condition is </span><span class="si">%s</span><span class="s1"> (min, max = </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">abs_Rdiag</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">abs_Rdiag</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="s1">&#39;Switching to QRP solution&#39;</span><span class="p">)</span>
            <span class="n">QR</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lapack</span><span class="o">.</span><span class="n">dgeqp3</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">P</span><span class="p">[:]</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># Switch to python 0-based indexing.</span>
            <span class="n">abs_Rdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">QR</span><span class="p">))</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">abs_Rdiag</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">abs_Rdiag</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="s1">&#39;Condition for QRP is </span><span class="si">%s</span><span class="s1"> (min, max = </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">abs_Rdiag</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">abs_Rdiag</span><span class="p">))</span>
            <span class="c1"># Skip any rows of R that have essentially 0 on the diagonal.</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">abs_Rdiag</span> <span class="o">&gt;</span> <span class="mf">1.e-15</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">abs_Rdiag</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;k = </span><span class="si">%d</span><span class="s1">, m = </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">m</span>

        <span class="c1"># The next steps are the same regardless of whether we pivoted or not.</span>
        <span class="c1"># This computes y = Q.T b</span>
        <span class="n">dq</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lapack</span><span class="o">.</span><span class="n">dormqr</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">QR</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">work</span><span class="p">)</span>
        <span class="c1"># Cut dq down to the first m elements, since it is still the size of b here.</span>
        <span class="n">dq</span> <span class="o">=</span> <span class="n">dq</span><span class="p">[:</span><span class="n">m</span><span class="p">]</span>
        <span class="c1"># Solve R dq = y (in place)</span>
        <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lapack</span><span class="o">.</span><span class="n">dtrtrs</span><span class="p">(</span><span class="n">QR</span><span class="p">[:</span><span class="n">k</span><span class="p">,:</span><span class="n">k</span><span class="p">],</span> <span class="n">dq</span><span class="p">[:</span><span class="n">k</span><span class="p">],</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Apply the permuation if we have one.</span>
            <span class="n">dq1</span> <span class="o">=</span> <span class="n">dq</span>
            <span class="n">dq1</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">dq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">dq</span><span class="p">[</span><span class="n">P</span><span class="p">]</span> <span class="o">=</span> <span class="n">dq1</span><span class="p">[:</span><span class="n">m</span><span class="p">]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;...finished solution&#39;</span><span class="p">)</span>
        <span class="c1"># Reshape dq back into a 2d array and add it to the current solution.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">+=</span> <span class="n">dq</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterp._solve_direct">
<a class="viewcode-back" href="../../interp.html#piff.BasisInterp._solve_direct">[docs]</a>
    <span class="k">def</span> <span class="nf">_solve_direct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stars</span><span class="p">,</span> <span class="n">logger</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;cpp&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solve_direct_cpp</span><span class="p">(</span><span class="n">stars</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solve_direct_python</span><span class="p">(</span><span class="n">stars</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_solve_direct_cpp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stars</span><span class="p">,</span> <span class="n">logger</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The implementation in C++ of solve() when use_qr = False.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Ks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">As</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stars</span><span class="p">:</span>
            <span class="c1"># Get the basis function values at this star</span>
            <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">Ks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
            <span class="n">As</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
            <span class="n">bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">dq</span> <span class="o">=</span> <span class="n">_piff</span><span class="o">.</span><span class="n">_solve_direct_cpp</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">As</span><span class="p">,</span> <span class="n">Ks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">+=</span> <span class="n">dq</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_solve_direct_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stars</span><span class="p">,</span> <span class="n">logger</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The implementation in python of solve() when use_qr = False.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Build ATA and ATb by accumulating the chunks for each star as we go.</span>
        <span class="n">nq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ATA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nq</span><span class="p">,</span> <span class="n">nq</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ATb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;jax&quot;</span><span class="p">:</span>
            <span class="n">Ks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">alphas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">betas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stars</span><span class="p">:</span>
                <span class="c1"># Get the basis function values at this star</span>
                <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">Ks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
                <span class="n">alphas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
                <span class="n">betas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>
            <span class="n">alphas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alphas</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">alphas</span><span class="p">),</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">betas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">),</span> <span class="n">betas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">Ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ks</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">Ks</span><span class="p">),</span> <span class="n">Ks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">ATA</span><span class="p">,</span> <span class="n">ATb</span> <span class="o">=</span> <span class="n">vmap_build_ATA_ATb</span><span class="p">(</span><span class="n">Ks</span><span class="p">,</span> <span class="n">alphas</span><span class="p">,</span> <span class="n">betas</span><span class="p">)</span>
            <span class="n">ATA</span> <span class="o">=</span> <span class="n">ATA</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span><span class="n">nq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stars</span><span class="p">:</span>
                <span class="c1"># Get the basis function values at this star</span>
                <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="c1"># Sum contributions into ATA, ATb</span>

                <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">alpha</span>
                    <span class="n">beta</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">beta</span>
                    <span class="n">ATb</span> <span class="o">+=</span> <span class="p">(</span><span class="n">beta</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">tmp1</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">K</span>
                    <span class="n">tmp2</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp1</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:]</span>
                    <span class="n">ATA</span> <span class="o">+=</span> <span class="n">tmp2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nq</span><span class="p">,</span><span class="n">nq</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="c1"># This is equivalent, but slower.</span>
                    <span class="c1"># It is here to make more explicit the connection between this calculation</span>
                    <span class="c1"># and the corresponding part of the QR code above.</span>
                    <span class="n">A1</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">A</span><span class="p">[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">K</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="p">))</span>
                    <span class="n">ATb</span> <span class="o">+=</span> <span class="n">A1</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
                    <span class="n">ATA</span> <span class="o">+=</span> <span class="n">A1</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A1</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="s1">&#39;Beginning solution of matrix size </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">ATA</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
                <span class="c1"># Note: It is usually ok to assume positive definite.  It is pretty rare that</span>
                <span class="c1"># assuming just &#39;sym&#39; instead (which does an LDL decomposition rather than</span>
                <span class="c1"># Cholesky) would help.  If this fails, the matrix is usually high enough</span>
                <span class="c1"># condition that it is functionally singular, and switching to SVD is warranted.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;jax&quot;</span><span class="p">:</span>
                    <span class="n">dq</span> <span class="o">=</span> <span class="n">jax_solve</span><span class="p">(</span><span class="n">ATA</span><span class="p">,</span> <span class="n">ATb</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dq</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">ATA</span><span class="p">,</span> <span class="n">ATb</span><span class="p">,</span> <span class="n">assume_a</span><span class="o">=</span><span class="s1">&#39;pos&#39;</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># scipy likes to warn about high condition.  They aren&#39;t actually a problem</span>
                <span class="c1"># though, and in practice, we found in DES data that switching to SVD whenever</span>
                <span class="c1"># scipy thought the condition was high led to a significant increase in the mean</span>
                <span class="c1"># size rediduals.  We don&#39;t have a unit test that would catch this, so be careful</span>
                <span class="c1"># about changing the behavior of this part of the code!  For now, we just go to</span>
                <span class="c1"># the svd solution when ATA is fully singular.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;norm(ATA dq - ATb) = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ATA</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dq</span><span class="p">)</span> <span class="o">-</span> <span class="n">ATb</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;norm(dq) = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dq</span><span class="p">))</span>

        <span class="k">except</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="s1">&#39;Caught </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="s1">&#39;Switching to svd solution&#39;</span><span class="p">)</span>
            <span class="n">Sd</span><span class="p">,</span><span class="n">U</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">ATA</span><span class="p">)</span>
            <span class="n">nsvd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.e-15</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="s1">&#39;2-condition is </span><span class="si">%e</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">Sd</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="s1">&#39;nsvd = </span><span class="si">%d</span><span class="s1"> of </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">nsvd</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">Sd</span><span class="p">))</span>
            <span class="c1"># Note: unlike scipy.linalg.svd, the Sd here is in *ascending* order, not descending.</span>
            <span class="n">Sd</span><span class="p">[</span><span class="o">-</span><span class="n">nsvd</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">Sd</span><span class="p">[</span><span class="o">-</span><span class="n">nsvd</span><span class="p">:]</span>
            <span class="n">Sd</span><span class="p">[:</span><span class="o">-</span><span class="n">nsvd</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Sd</span><span class="p">)</span>
            <span class="n">dq</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ATb</span><span class="p">)))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="s1">&#39;norm(ATA dq - ATb) = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ATA</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dq</span><span class="p">)</span> <span class="o">-</span> <span class="n">ATb</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="s1">&#39;norm(dq) = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dq</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="s1">&#39;norm(q) = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">))</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;...finished solution&#39;</span><span class="p">)</span>
        <span class="c1"># Reshape dq back into a 2d array and add it to the current solution.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">+=</span> <span class="n">dq</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<div class="viewcode-block" id="BasisInterp.interpolate">
<a class="viewcode-back" href="../../interp.html#piff.BasisInterp.interpolate">[docs]</a>
    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform the interpolation to find the interpolated parameter vector at some position.</span>

<span class="sd">        :param star:        A Star instance to which one wants to interpolate</span>
<span class="sd">        :param logger:      A logger object for logging debug info. [default: None]</span>
<span class="sd">        :param inplace:     Whether to update the parameters in place, in which case the</span>
<span class="sd">                            returned star is the same object as the input star. [default: False]</span>

<span class="sd">        :returns: a Star instance holding the interpolated parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Attempt to interpolate() before initialize() of BasisInterp&quot;</span><span class="p">)</span>

        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">star</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span><span class="n">K</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">updateParams</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">star</span> <span class="o">=</span> <span class="n">Star</span><span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">newParams</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">star</span></div>
</div>



<div class="viewcode-block" id="BasisPolynomial">
<a class="viewcode-back" href="../../interp.html#piff.BasisPolynomial">[docs]</a>
<span class="k">class</span> <span class="nc">BasisPolynomial</span><span class="p">(</span><span class="n">BasisInterp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A version of the Polynomial interpolator that works with BasisModels and can use the</span>
<span class="sd">    quadratic form of the chisq information it calculates.  It works better than the regular</span>
<span class="sd">    Polynomial interpolator when there is missing or degenerate information.</span>

<span class="sd">    The order is the highest power of a key to be used.  This can be the same for all keys</span>
<span class="sd">    or you may provide a list of separate order values to be used for each key.  (e.g. you</span>
<span class="sd">    may want to use 2nd order in the positions, but only 1st order in the color).</span>

<span class="sd">    All combinations of powers of keys that have total order &lt;= max_order are used.</span>
<span class="sd">    The maximum order is normally the maximum order of any given key&#39;s order, but you may</span>
<span class="sd">    specify a larger value.  (e.g. to use 1, x, y, xy, you would specify order=1, max_order=2.)</span>

<span class="sd">    There are several options for what code to use for doing the linear algebra, controlled</span>
<span class="sd">    by the ``solver`` parameter, which can take one of the following values:</span>

<span class="sd">    1. &quot;scipy&quot; uses regular numpy array functionality to build the matrices, and then uses</span>
<span class="sd">       ``scipy.linalg.solve`` to find the solution.  It starts by assuming the matrix</span>
<span class="sd">       is positive definite, and it falls back to an SVD solution when that is not the case.</span>
<span class="sd">    2. &quot;qr&quot; will also use numpy to build the matrices, but then it uses QR decomposition</span>
<span class="sd">       for the solution rather than the more direct least squares solution.</span>
<span class="sd">       QR decomposition requires more memory than the default and is somewhat slower</span>
<span class="sd">       (nearly a factor of 2); however, it is significantly less susceptible to</span>
<span class="sd">       numerical errors from high condition matrices.</span>
<span class="sd">    3. &quot;jax&quot; uses the JAX module for building and solving the linear algebra equations</span>
<span class="sd">       rather than numpy/scipy. It should be equivalent in its results to the &quot;scipy&quot; option,</span>
<span class="sd">       but it may be faster if a multi-core cpu or gpu is available.</span>
<span class="sd">    4. &quot;cpp&quot; uses the Eigen linear algebra package in C++ to build and solve the linear</span>
<span class="sd">       algebra equations rather than numpy/scipy.  On a single core cpu (and more), it</span>
<span class="sd">       will be faster than default &quot;scipy&quot; solver if the number of training stars is more</span>
<span class="sd">       than ~30. With a Piff config using `PixelGrid` with ``size=25`` and ``interp=&quot;Lanczos(11)&quot;``</span>
<span class="sd">       and a second order polynomial for interpolation, and running on ~O(100) PSFs reserved</span>
<span class="sd">       stars on a 4GB single core CPU, &quot;cpp&quot; solver is 60% faster than &quot;scipy&quot; solver.</span>

<span class="sd">    Use type name &quot;BasisPolynomial&quot; in a config field to use this interpolant.</span>

<span class="sd">    :param order:       The order to use for each key.  Can be a single value (applied to all</span>
<span class="sd">                        keys) or an array matching number of keys.</span>
<span class="sd">    :param keys:        List of keys for properties that will be used as the polynomial arguments.</span>
<span class="sd">                        [default: (&#39;u&#39;,&#39;v&#39;)]</span>
<span class="sd">    :param max_order:   The maximum total order to use for cross terms between keys.</span>
<span class="sd">                        [default: None, which uses the maximum value of any individual key&#39;s order]</span>
<span class="sd">                        If this is an integer, it applies to all pairs, but you may also specify</span>
<span class="sd">                        a dict mapping pairs of keys to an integer.  E.g. {(&#39;u&#39;,&#39;v&#39;):3,</span>
<span class="sd">                        (&#39;u&#39;,&#39;z&#39;):0, (&#39;v&#39;,&#39;z&#39;):0}.  This sets the maximum order for cross terms</span>
<span class="sd">                        between these pairs.  Furthermore, any pairs for which you want to skip</span>
<span class="sd">                        cross terms (max=0) may be omitted from the dict.</span>
<span class="sd">    :param solver:      Which solver to use.  Solvers available are &quot;scipy&quot;, &quot;qr&quot;, &quot;jax&quot;,</span>
<span class="sd">                        &quot;cpp&quot;. See above for details. [default: &#39;scipy&#39;]</span>
<span class="sd">    :param logger:      A logger object for logging debug info. [default: None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_type_name</span> <span class="o">=</span> <span class="s1">&#39;BasisPolynomial&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">order</span><span class="p">,</span>
            <span class="n">keys</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span><span class="s1">&#39;v&#39;</span><span class="p">),</span>
            <span class="n">max_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">solver</span><span class="o">=</span><span class="s2">&quot;scipy&quot;</span><span class="p">,</span>
            <span class="n">use_qr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BasisPolynomial</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerWrapper</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span> <span class="o">=</span> <span class="n">keys</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of provided orders does not match number of keys&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orders</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orders</span> <span class="o">=</span> <span class="p">(</span><span class="n">order</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orders</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_order</span> <span class="o">=</span> <span class="n">max_order</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>

        <span class="n">valid_solver</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;scipy&quot;</span><span class="p">,</span> <span class="s2">&quot;qr&quot;</span><span class="p">,</span> <span class="s2">&quot;jax&quot;</span><span class="p">,</span> <span class="s2">&quot;cpp&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">solver</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_solver</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">solver</span><span class="si">}</span><span class="s2"> is not a valid solver. Valid solver are </span><span class="si">{</span><span class="n">valid_solver</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># To match old API when jax and cpp were not part of solving</span>
        <span class="c1"># basis interp.</span>
        <span class="k">if</span> <span class="n">use_qr</span> <span class="ow">and</span> <span class="n">solver</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;scipy&quot;</span><span class="p">,</span> <span class="s2">&quot;qr&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;use_qr and </span><span class="si">{</span><span class="n">solver</span><span class="si">}</span><span class="s2"> are not compatible&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_qr</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;WARNING: use_qr=True is deprecated. &quot;</span>
                         <span class="s2">&quot;Use solver=&#39;qr&#39; instead.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;qr&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">CAN_USE_JAX</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;jax&quot;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;JAX not installed. Reverting to numpy/scipy.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;scipy&quot;</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orders</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># Exception if we have any requests for negative orders</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Negative polynomial order specified&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;order&#39;</span> <span class="p">:</span> <span class="n">order</span><span class="p">,</span>
            <span class="s1">&#39;max_order&#39;</span> <span class="p">:</span> <span class="n">max_order</span><span class="p">,</span>
            <span class="s1">&#39;keys&#39;</span> <span class="p">:</span> <span class="n">keys</span><span class="p">,</span>
            <span class="s1">&#39;solver&#39;</span><span class="p">:</span> <span class="n">solver</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Now build a mask that picks the desired polynomial products</span>
        <span class="c1"># Start with 1d arrays giving orders in all dimensions</span>
        <span class="n">ord_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orders</span><span class="p">]</span>
        <span class="c1"># Nifty trick to produce n-dim array holding total order</span>
        <span class="n">sumorder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">ord_ranges</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_order</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># This code is not particularly efficient.  Hopefully it doesn&#39;t matter.</span>
            <span class="c1"># Basically set a maxorder for each element in sumorder based on whether it is</span>
            <span class="c1"># a) a power of a single key.  Use the order for that key.</span>
            <span class="c1"># b) a cross-product of multiple keys.  Use it only if it is in the max_order dict.</span>
            <span class="n">max_orders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sumorder</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">get_indices</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="p">()):</span>
                <span class="c1"># Get the index tuples of the given multi-dimensional array.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">pre</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
                        <span class="k">yield from</span> <span class="n">get_indices</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pre</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,))</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">get_indices</span><span class="p">(</span><span class="n">sumorder</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orders</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">index</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">k</span><span class="p">):</span>
                        <span class="n">max_orders</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span>
                <span class="k">for</span> <span class="n">keys</span><span class="p">,</span> <span class="n">order</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_order</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">kk</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orders</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">index</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kk</span><span class="p">:</span> <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="n">index</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kk</span><span class="p">:</span> <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
                        <span class="n">max_orders</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_order</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">sumorder</span> <span class="o">&lt;=</span> <span class="n">max_orders</span>

<div class="viewcode-block" id="BasisPolynomial.getProperties">
<a class="viewcode-back" href="../../interp.html#piff.BasisPolynomial.getProperties">[docs]</a>
    <span class="k">def</span> <span class="nf">getProperties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">property_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of properties used by this interpolant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>

<div class="viewcode-block" id="BasisPolynomial.basis">
<a class="viewcode-back" href="../../interp.html#piff.BasisPolynomial.basis">[docs]</a>
    <span class="k">def</span> <span class="nf">basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return 1d array of polynomial basis values for this star</span>

<span class="sd">        :param star:   A Star instance</span>

<span class="sd">        :returns:      1d numpy array with values of u^i v^j for 0&lt;i+j&lt;=order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the interpolation key values</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getProperties</span><span class="p">(</span><span class="n">star</span><span class="p">)</span>

        <span class="c1"># Make 1d arrays of all needed powers of keys</span>
        <span class="n">pows1d</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orders</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">o</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">pows1d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

        <span class="c1"># Make outer product of all these powers</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pows1d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This is faster than the line below.</span>
            <span class="n">pows2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="o">*</span><span class="n">pows1d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pows2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">pows1d</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Return linear array of terms making total power constraint</span>
        <span class="k">return</span> <span class="n">pows2d</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span></div>


<div class="viewcode-block" id="BasisPolynomial.constant">
<a class="viewcode-back" href="../../interp.html#piff.BasisPolynomial.constant">[docs]</a>
    <span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return 1d array of coefficients that represent a polynomial with constant value.</span>

<span class="sd">        :param value:  The value to use as the constant term.  [default: 1.]</span>

<span class="sd">        :returns:      1d numpy array with values of u^i v^j for 0&lt;i+j&lt;=order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># The constant term is always first.</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="BasisPolynomial._finish_write">
<a class="viewcode-back" href="../../interp.html#piff.BasisPolynomial._finish_write">[docs]</a>
    <span class="k">def</span> <span class="nf">_finish_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the solution.</span>

<span class="sd">        :param writer:      A writer object that encapsulates the serialization format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Solution not set yet.  Cannot write this BasisPolynomial.&quot;</span><span class="p">)</span>

        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write_table</span><span class="p">(</span><span class="s1">&#39;solution&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisPolynomial._finish_read">
<a class="viewcode-back" href="../../interp.html#piff.BasisPolynomial._finish_read">[docs]</a>
    <span class="k">def</span> <span class="nf">_finish_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the solution.</span>

<span class="sd">        :param reader:      A reader object that encapsulates the serialization format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="s1">&#39;solution&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>